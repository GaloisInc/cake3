{-# LANGUAGE FlexibleInstances #-}
module Development.Cake3.Writer (buildMake, makefile) where

import Control.Applicative
import Control.Monad (when)
import Control.Monad.State (State(..), execState, evalState, runState, modify, get, put)
import Data.List as L
import Data.Char
import Data.Monoid
import Data.String
import Data.Foldable (forM_)
import Data.Traversable (forM)
import Data.Set (Set)
import qualified Data.Set as S
import Data.Map (Map)
import qualified Data.Map as M
import Text.Printf

import System.FilePath.Wrapper
import Development.Cake3.Types
import Development.Cake3.Monad

class ToMakeText x where
  toMakeText :: x -> String
  
instance ToMakeText [Char] where
  toMakeText = id

instance ToMakeText [[Char]] where
  toMakeText = concat . map toMakeText

instance ToMakeText File where
  toMakeText (FileT f) = escape f where
    escape [] = []
    escape (' ':xs) = "\\ " ++ escape xs
    escape (x:xs) = (x:(escape xs))

trimE = dropWhileEnd isSpace
trimB = dropWhile isSpace

cs a b = a ++ (' ':b)

instance ToMakeText Command where
  toMakeText [x] = either toMakeText toMakeText x
  toMakeText ((Left str):(Right f):cmd) = toMakeText ((Left ((trimE str)`cs` (toMakeText f))):cmd)
  toMakeText ((Right f):(Left str):cmd) = toMakeText ((Left ((toMakeText f)`cs`(trimB str))):cmd)
  toMakeText ((Right a):(Right b):cmd) = toMakeText ((Left ((toMakeText a)`cs`(toMakeText b))):cmd)
  toMakeText ((Left s1):(Left s2):cmd) = toMakeText ((Left (s1++s2)):cmd)

smap f = map f . S.toList

line :: String -> State String ()
line s = modify $ \ws -> concat [ws, s, "\n"]

type Tmp a = State [Int] a

fresh :: Tmp File
fresh = do
  (i:is) <- get
  put is
  return $ fromFilePath ("." </> (printf ".stamp%d" i))

runTmp :: Tmp a -> a
runTmp t = evalState t [1..]

fixMultiTarget :: Set Recipe -> Set Recipe
fixMultiTarget rs = runTmp (transformRecipes f rs) where
  f r | (S.size (rtgt r)) > 1 = do
        s <- fresh
        let r1 = r {rsrc = (S.singleton s), rcmd = mempty, rvars = mempty}
        let r2 = r {rtgt = (S.singleton s), rcmd = (rcmd r) ++ [[Left "touch", Right s]] }
        return $ S.fromList [r1,r2]
      | otherwise = return (S.singleton r)

completeMultiTarget :: Set Recipe -> Set Recipe
completeMultiTarget rs = 
  let
    badlist = S.foldl' (\ts r -> do
      if (S.size (rtgt r)) > 1 then (rtgt r):ts else ts) [] rs
  in
    flip S.map rs $ \r ->
      L.foldl' (\r mulpack ->
        case (not . S.null) ((rsrc r)`S.intersection` mulpack) of
          True -> r { rsrc = (rsrc r) `S.union` mulpack }
          False -> r) r badlist

makefile :: File
makefile = fromFilePath "Makefile"

addRebuildDeps :: Set File -> Set Recipe -> Set Recipe
addRebuildDeps deps rs = S.map mkd rs where
  mkd r | makefile `S.member` (rtgt r) = addPrerequisites deps r
        | otherwise = r

isRequiredFor :: Set Recipe -> Recipe -> File -> Bool
isRequiredFor rs r f = if f`S.member`(rtgt r) then True else godeeper where
  godeeper = or $ map (\tgt -> or $ map (\r -> isRequiredFor rs r f) (selectBySrc tgt)) (S.toList $ rtgt r)
  selectBySrc f = S.toList . fst $ S.partition (\r -> f`S.member`(rsrc r)) rs

-- | There are only 2 kind of rules: 1) ones that depend on a Makefile, and 2) ones
-- that Makefile depends on. Case-2 is known in advance (for example, when the
-- the contents of a file is required to build a Makefile then Makefile depends
-- on this file). This function adds the case-1 dependencies.
addMakeDeps :: Set Recipe -> Set Recipe
addMakeDeps rs
  | S.null (S.filter (\r -> makefile `S.member` (rtgt r)) rs) = rs
  | otherwise = S.map addMakeDeps_ rs
  where
    addMakeDeps_ r | not (isRequiredFor rs r makefile) = addPrerequisite makefile r
                   | otherwise = r

buildMake :: MakeState -> Either String String
buildMake ms = do
  rs <- return (recipes ms)
  vs <- queryVariablesE ms
  let rs' = applyPlacement (placement ms)
          $ fixMultiTarget
          $ completeMultiTarget
          $ addMakeDeps
          $ addRebuildDeps (makeDeps ms)
          $ rs
  return (writeMake vs rs')

writeMake vs rs = flip execState "" $ do
  line "# This Makefile was generated by the ThirdCake"
  line "# https://github.com/grwlf/cake3"
  line ""

  when (not (S.null vs)) $ do
    line "GUARD = .GUARD_$(1)_$(shell echo $($(1)) | md5sum | cut -d ' ' -f 1)"

  -- Variables
  forM_ vs $ \v -> case v of
    (Variable n (Just v)) -> line (printf "%s = %s" n v)
    (Variable n Nothing) -> return ()

  -- Rules
  forM_ rs $ \r -> do
    let varguard v = printf "$(call GUARD,%s)" (vname v)
    let deps = intercalate " " $ (smap toMakeText (rsrc r)) ++ (smap varguard (rvars r))
    let tgts = intercalate " " $ (smap toMakeText (rtgt r))

    when (rphony r) $ do
      line (printf ".PHONY: %s" tgts)

    line (printf "%s: %s" tgts deps)
    forM_ (rcmd r) $ \c -> do
      line (printf "\t%s" (toMakeText c))

  -- Rules for variable's guards
  -- FIXME: add those on the higher level
  forM_ vs $ \v -> do
    line (printf "$(call GUARD,%s):" (vname v))
    line (printf "\trm -f .GUARD_%s_*" (vname v))
    line "\ttouch $@"

