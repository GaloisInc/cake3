{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleInstances #-}
module Development.Cake3.Writer (toMake) where

import Prelude hiding (FilePath)
import Control.Applicative
import Control.Monad.State
import Data.List as L
import Data.String
import qualified Data.Text      as ST
import qualified Data.Text.Lazy as T
import           Data.Text.Lazy    (Text(..))
import qualified Data.Text.Lazy.IO as TIO
import Development.Cake3.Types
import Development.Cake3.Types as C3 (collapse)
-- import Text.Printf
import Filesystem.Path.CurrentOS as P hiding (null)
import Data.Text.Format

rule2vars r = let Uniq vs = fst $ C3.collapse (rvars r) in vs

gen :: MakeWriter Int
gen = do
  x <- head <$> cnt <$> get
  modify (\ws -> ws { cnt = tail (cnt ws) })
  return x

-- | Writer state
data WS = WS { cnt :: [Int] , ls :: Text }
  deriving(Show)

type MakeWriter a = State WS a

class ToMakeText x where
  toMakeText :: x -> Text
  
instance ToMakeText Text where
  toMakeText = id

instance ToMakeText String where
  toMakeText = toMakeText . T.pack 

instance ToMakeText [Text] where
  toMakeText = T.concat

instance ToMakeText ST.Text where
  toMakeText = T.fromStrict

instance ToMakeText FilePath where
  toMakeText p = escape $ toMakeText $ either id id (P.toText p) where
    escape = T.replace " " "\\ "

instance ToMakeText Command where
  toMakeText c = T.concat $ map (either toMakeText toMakeText) c

instance ToMakeText [FilePath] where
  toMakeText p = T.intercalate " " (map toMakeText p)

newtype T = T T.Text

instance ToMakeText T where
  toMakeText (T s) = toMakeText s

line :: (ToMakeText x) => x -> MakeWriter ()
line = tell1 . toMakeText where
  tell1 s = modify $ \ws -> ws { ls = T.concat [ls ws, s, "\n"] }

toMake ms =
  let (Uniq vs, e1) = C3.collapse (svars ms)
      (Uniq rs, e2) = collapseP (srecipes ms)
      er = e1 ++ e2
  in  ST.unpack $ T.toStrict $ ls $ flip execState (WS [1..] "") $ do

  line $ T "# This Makefile was generated by the ThirdCake"
  line $ T "# https://github.com/grwlf/cake3"
  line $ T ""

  line $ T "GUARD = .GUARD_$(1)_$(shell echo $($(1)) | md5sum | cut -d ' ' -f 1)"

  -- Variables
  forM_ vs $ \v -> case v of
    (Variable n (Just v)) -> line (format "{} = {}" (n,v))
    (Variable n Nothing) -> return ()

  -- Rules
  forM_ rs $ \r -> do
    let varguard v = format "$(call GUARD,{})" (Only $ vname v)
    let deps = T.intercalate " " $ (map toMakeText (rsrc r)) ++ (map varguard (rule2vars r))
    let tgts = T.intercalate " " $ (map toMakeText (rtgt r))

    when (rphony r) $ do
      line [format ".PHONY: {}" (Only tgts)]

    case (length (rtgt r)) of
      0 -> do
        return ()
      1 -> do
        let s = (head (rtgt r))
        line $ format "{} : {}" (toMakeText s, deps)
        forM_ (rcmd r) $ \c -> do
          line ["\t", toMakeText c]
      _ -> do
        i <- gen
        let s = format "stamp{}" (Only i)
        line [".INTERMEDIATE", ":",  s]
        line [format "{} : {}" (s, deps)]
        forM_ (rcmd r) $ \c -> do
          line ["\t", toMakeText c]
        line [format "{} : {}" (tgts, s)]

  -- Rules for variable's guards
  forM_ vs $ \v -> do
    line $ format "$(call GUARD,{}) :" (Only $ vname v)
    line $ format "\trm -f .GUARD_{}_*" (Only $ vname v)
    line $ T "\ttouch $@"

